# 시즌 필터링 도구와 데이터 출고 도구 통합 설계

## 📋 목차
1. [현재 상태 분석](#현재-상태-분석)
2. [통합 목표](#통합-목표)
3. [통합 방안](#통합-방안)
4. [구현 단계](#구현-단계)
5. [데이터 흐름](#데이터-흐름)
6. [API 설계](#api-설계)
7. [주의사항](#주의사항)

---

## 현재 상태 분석

### 1. 시즌 필터링 도구 (`season_filter_manager_gui.py`)

**현재 기능:**
- ✅ Excel 파일 로드 및 편집
- ✅ 시트별 탭으로 구분 (TYPE_PRESETS, SEASON_MASTER, KEYWORDS)
- ✅ 행 추가/삭제, 셀 편집
- ✅ Excel → JSON 컴파일 기능
- ✅ JSON 미리보기
- ⚠️ 자동 캐시 갱신 (mtime 기반) - 부분 구현

**주요 함수:**
- `filter_products_by_season()`: 상품 리스트를 시즌 필터로 필터링
- `_detect_seasons_from_product()`: 상품에서 시즌 키워드 감지
- `_check_season_validity()`: 시즌 유효성 검사

**미완성 부분:**
- ⚠️ `load_season_config()` 함수: Excel → JSON 자동 컴파일 및 캐시 로딩
- ⚠️ Excel 파싱 로직: 완전한 Excel → JSON 변환
- ⚠️ PREP 기간 처리: 4단계 시스템 (PREP/ACTIVE/GRACE/EXPIRE)

### 2. 데이터 출고 도구 (`data_export.py` + `main_window.py`)

**현재 기능:**
- ✅ 카테고리 선택
- ✅ 마켓/스토어 선택
- ✅ 상품 조합 생성 및 관리 (`product_combinations` 테이블)
- ✅ 마켓별 출력제한 기록 (`combination_assignments` 테이블)
- ✅ 데이터 출고 실행 (`_run_export_for_upload()`)
- ✅ 상품 조합 사용횟수 순서 관리

**주요 흐름:**
```
1. 카테고리 선택
   ↓
2. get_products_for_upload() 호출
   ↓
3. product_combinations 테이블에서 조합 조회
   ↓
4. combination_assignments 테이블에서 할당 정보 확인
   ↓
5. 사용 가능한 조합 선택
   ↓
6. 엑셀 파일 생성 및 출고
```

**시즌 필터링 미적용:**
- ❌ 상품 조회 시 시즌 필터링 없음
- ❌ 상품조합 생성 시 시즌 필터링 없음

---

## 통합 목표

### 핵심 원칙

1. **상품조합 생성 전 필터링**
   - 시즌 필터링은 `product_combinations` 테이블 생성 전에 적용
   - 필터링된 상품은 조합 생성 자체가 안 됨

2. **마켓별 출력제한 기록 전 필터링**
   - 시즌 필터링은 `combination_assignments` 테이블 확인 전에 수행
   - 이미 할당된 조합 기록에 영향을 미치지 않음

3. **자동 캐시 갱신**
   - Excel 파일 수정 시 자동으로 JSON 재생성
   - "설정 저장" 버튼 불필요

4. **운영 편의성**
   - Excel만 수정하면 자동 반영
   - GUI는 선택적으로 사용

---

## 통합 방안

### 방안 1: 하이브리드 방식 (최종 추천) ⭐⭐⭐⭐⭐

**구조:**
```
season_filter_manager_gui.py (독립 실행)
├── Excel 편집 기능
├── JSON 컴파일 기능
└── Excel 구조 확인

data_export.py (통합)
├── 자동 캐시 로딩 (load_season_config)
├── 시즌 필터링 적용
└── "시즌 필터 설정" 버튼 (선택적)
```

**장점:**
- ✅ 운영 난이도 최소 (Excel만 수정하면 자동 반영)
- ✅ 유연성 (독립 실행 또는 통합 사용 가능)
- ✅ 안정성 (자동 캐시로 Excel 문제 시에도 이전 설정 사용)

**단점:**
- ⚠️ 초기 구현 복잡도 중간

---

## 구현 단계

### Phase 1: 핵심 기능 구현 (필수)

#### 1.1 `season_filter_manager_gui.py`에 유틸리티 함수 추가

**파일:** `database/season_filter_loader.py` (신규 생성)

```python
def load_season_config(excel_path: str, json_path: str) -> Optional[Dict]:
    """
    시즌 설정 로딩 (자동 캐시 갱신)
    
    Args:
        excel_path: Excel 파일 경로
        json_path: JSON 캐시 파일 경로
    
    Returns:
        시즌 설정 딕셔너리 또는 None
    """
    # 1. Excel 파일 존재 확인
    if not os.path.exists(excel_path):
        # Excel이 없으면 JSON만 사용
        if os.path.exists(json_path):
            with open(json_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        return None  # 둘 다 없으면 None 반환
    
    # 2. JSON 캐시 존재 및 최신성 확인 (mtime 기반)
    excel_mtime = os.path.getmtime(excel_path)
    json_exists = os.path.exists(json_path)
    
    if json_exists:
        json_mtime = os.path.getmtime(json_path)
        # JSON이 최신이면 바로 로딩
        if json_mtime >= excel_mtime:
            try:
                with open(json_path, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                return config
            except Exception as e:
                print(f"[시즌 필터] JSON 로딩 실패: {e}, Excel에서 재생성")
    
    # 3. Excel이 더 최신이거나 JSON이 없으면 재생성
    try:
        config = parse_excel_to_config(excel_path)
        
        # JSON 저장
        os.makedirs(os.path.dirname(json_path), exist_ok=True)
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(config, f, ensure_ascii=False, indent=2)
        
        return config
        
    except Exception as e:
        # Excel 파싱 실패 시
        if json_exists:
            print(f"[시즌 필터] ⚠️ Excel 파싱 실패: {e}")
            print(f"[시즌 필터] 이전 JSON 캐시 사용")
            with open(json_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        else:
            print(f"[시즌 필터] ⚠️ Excel 파싱 실패 및 JSON 캐시 없음: {e}")
            return None

def parse_excel_to_config(excel_path: str) -> Dict:
    """
    Excel 파일을 읽어서 JSON 구조로 변환
    
    Args:
        excel_path: Excel 파일 경로
    
    Returns:
        시즌 설정 딕셔너리
    """
    import pandas as pd
    
    # Excel 시트 읽기
    df_types = pd.read_excel(excel_path, sheet_name='TYPE_PRESETS')
    df_seasons = pd.read_excel(excel_path, sheet_name='SEASON_MASTER')
    df_keywords = pd.read_excel(excel_path, sheet_name='KEYWORDS')
    
    # JSON 구조로 변환
    config = {
        "version": "2.0",
        "settings": {
            "filter_mode": "exclude_expired",
            "case_sensitive": False
        },
        "types": {},
        "seasons": []
    }
    
    # TYPE_PRESETS 처리
    for _, row in df_types.iterrows():
        type_id = row['타입ID']
        config["types"][type_id] = {
            "prep_days": int(row['prep_days']),
            "grace_days": int(row['grace_days']),
            "score_min": int(row.get('score_min', 1))
        }
    
    # SEASON_MASTER 처리
    for _, row in df_seasons.iterrows():
        season_id = row['시즌ID']
        type_id = row['타입ID']
        
        # 타입 기본값 가져오기
        type_defaults = config["types"].get(type_id, {})
        
        season = {
            "id": season_id,
            "name": row['시즌명'],
            "type": type_id,
            "start_date": row['시작일'],
            "end_date": row['종료일'],
            "cross_year": bool(row.get('cross_year', False)),
            "prep_days": int(row.get('prep_override', type_defaults.get('prep_days', 30))),
            "grace_days": int(row.get('grace_override', type_defaults.get('grace_days', 7))),
            "priority": int(row.get('priority', 1)),
            "keywords": {
                "include": [],
                "exclude": []
            }
        }
        
        # KEYWORDS 처리
        season_keywords = df_keywords[df_keywords['시즌ID'] == season_id]
        for _, kw_row in season_keywords.iterrows():
            keyword = kw_row['키워드']
            polarity = kw_row['polarity']  # "include" or "exclude"
            weight = float(kw_row.get('가중치', 1.0))
            
            season["keywords"][polarity].append({
                "keyword": keyword,
                "weight": weight
            })
        
        config["seasons"].append(season)
    
    return config
```

#### 1.2 `db_handler.py`에 시즌 필터링 통합

**수정 위치:** `get_products_for_upload()` 메서드

```python
def get_products_for_upload(self, category: str, sheet_name: str, 
                            business_number: str, status: str = 'ACTIVE', 
                            exclude_assigned: bool = True,
                            season_config: Optional[Dict] = None) -> List[Dict]:
    """
    마켓 업로드용 상품 조회 (시즌 필터링 포함)
    
    Args:
        category: 카테고리명
        sheet_name: 시트명 (마켓 타입)
        business_number: 사업자번호
        status: 상품 상태 (기본: ACTIVE)
        exclude_assigned: 이미 배정된 상품코드 제외 여부 (기본: True)
        season_config: 시즌 필터 설정 (None이면 자동 로드)
    
    Returns:
        업로드 가능한 상품 리스트 (조합 인덱스 순서로 정렬)
    """
    cursor = self.conn.cursor()
    
    # 1. 시즌 필터 설정 로드 (없으면 자동 로드)
    if season_config is None:
        season_config = self._load_season_config()
    
    # 2. 카테고리 패턴 생성
    category_parts = [part.strip() for part in category.split('>')]
    if len(category_parts) >= 2:
        large_cat = category_parts[0].strip()
        medium_cat = category_parts[1].strip()
        category_pattern = f"%{large_cat}%>%{medium_cat}%"
    else:
        category_pattern = f"%{category}%"
    
    # 3. 카테고리로 상품 조회
    cursor.execute("""
        SELECT DISTINCT p.상품코드, p.*
        FROM products p
        WHERE p.카테고리명 LIKE ? 
        AND p.product_status = ?
        AND (p.누끼url IS NOT NULL AND p.누끼url != '' OR p.믹스url IS NOT NULL AND p.믹스url != '')
        AND p.product_names_json IS NOT NULL 
        AND p.product_names_json != '' 
        AND p.product_names_json != '[]'
    """, (category_pattern, status))
    
    products = [dict(row) for row in cursor.fetchall()]
    
    # 4. 시즌 필터링 적용 (상품조합 생성 전 필터링)
    if season_config:
        from season_filter_manager_gui import filter_products_by_season
        products, excluded_count, excluded_seasons = filter_products_by_season(
            products, season_config
        )
        # 로그는 main_window에서 처리
    
    # 5. 이미 할당된 조합 인덱스 조회 (시트 전체)
    # ... (기존 로직)
    
    # 6. 각 상품코드별로 사용 가능한 조합 조회
    # ... (기존 로직)
    
    return result

def _load_season_config(self) -> Optional[Dict]:
    """
    시즌 필터 설정 로드
    
    Returns:
        시즌 설정 딕셔너리 또는 None
    """
    try:
        from database.season_filter_loader import load_season_config
        
        excel_path = os.path.join(
            os.path.dirname(os.path.dirname(__file__)),
            "Season_Filter_Seasons_Keywords.xlsx"
        )
        json_path = os.path.join(
            os.path.dirname(os.path.dirname(__file__)),
            "season_filters.json"
        )
        
        return load_season_config(excel_path, json_path)
    except Exception as e:
        print(f"[시즌 필터] 설정 로딩 실패: {e}")
        return None
```

#### 1.3 `main_window.py`에 시즌 필터링 통합

**수정 위치:** `_run_export_for_upload()` 메서드

```python
def _run_export_for_upload(self, ...):
    """마켓 업로드용 데이터 출고 실행"""
    # ... 기존 코드 ...
    
    # 시즌 필터 설정 로드
    season_config = None
    try:
        from database.season_filter_loader import load_season_config
        excel_path = os.path.join(
            os.path.dirname(os.path.dirname(__file__)),
            "Season_Filter_Seasons_Keywords.xlsx"
        )
        json_path = os.path.join(
            os.path.dirname(os.path.dirname(__file__)),
            "season_filters.json"
        )
        season_config = load_season_config(excel_path, json_path)
        if season_config:
            self._log("✅ 시즌 필터 설정 로드 완료")
        else:
            self._log("ℹ️ 시즌 필터 설정 없음 (필터링 건너뜀)")
    except Exception as e:
        self._log(f"⚠️ 시즌 필터 설정 로드 실패: {e}")
    
    # ... 기존 코드 ...
    
    # get_products_for_upload 호출 시 season_config 전달
    products = db_handler.get_products_for_upload(
        category, sheet_name, business_number, 
        exclude_assigned=exclude_assigned,
        season_config=season_config
    )
```

**UI 추가 (선택적):**

```python
# 시즌 필터링 설정 프레임 추가
frame_season = ttk.LabelFrame(main_frame, text="🗓️ 시즌 필터링", padding=10)
frame_season.pack(fill='x', pady=(0, 10))

# 시즌 필터링 활성화 체크박스
self.season_filter_enabled = tk.BooleanVar(value=True)
ttk.Checkbutton(
    frame_season, 
    text="시즌 필터링 활성화 (현재 시즌이 지난 상품 자동 제외)",
    variable=self.season_filter_enabled
).pack(side='left', padx=5)

# 시즌 설정 관리 버튼
btn_season_config = ttk.Button(
    frame_season, 
    text="⚙️ 시즌 설정 관리",
    command=self._open_season_filter_manager
)
btn_season_config.pack(side='right', padx=5)

def _open_season_filter_manager(self):
    """시즌 필터 관리 창 열기"""
    from season_filter_manager_gui import SeasonFilterManagerGUI
    manager = SeasonFilterManagerGUI()
    manager.mainloop()
```

### Phase 2: 고급 기능 (선택)

#### 2.1 점수제 시즌 감지
- include/exclude 키워드 분리
- score 계산 및 score_min 임계값

#### 2.2 PREP 기간 처리
- 4단계 시스템 (PREP/ACTIVE/GRACE/EXPIRE)
- 소싱/가공 기간 고려

---

## 데이터 흐름

### 전체 흐름도

```
[사용자]
  ↓
[Excel 파일 편집] (season_filter_manager_gui.py)
  ↓
[Excel 저장]
  ↓
[data_export.py 실행]
  ↓
[load_season_config() 호출]
  ├─ Excel mtime vs JSON mtime 비교
  ├─ Excel이 더 최신이면 → parse_excel_to_config() → JSON 저장
  └─ JSON 로딩
  ↓
[get_products_for_upload() 호출]
  ├─ 카테고리로 상품 조회
  ├─ 시즌 필터링 적용 (filter_products_by_season)
  │   ├─ 시즌 감지 (_detect_seasons_from_product)
  │   └─ 시즌 유효성 검사 (_check_season_validity)
  ├─ 필터링된 상품만 남김
  ├─ product_combinations 테이블에서 조합 조회
  ├─ combination_assignments 테이블에서 할당 정보 확인
  └─ 사용 가능한 조합 반환
  ↓
[엑셀 파일 생성 및 출고]
```

### 시즌 필터링 적용 시점

```
1. 상품 조회 (카테고리 기준)
   ↓
2. [시즌 필터링 적용] ← 여기서 필터링
   ↓
3. product_combinations 테이블 조회
   ↓
4. combination_assignments 테이블 확인
   ↓
5. 사용 가능한 조합 선택
```

**중요:** 시즌 필터링은 **상품조합 생성 전**과 **마켓별 출력제한 기록 확인 전**에 수행되어야 함.

---

## API 설계

### 1. `load_season_config(excel_path, json_path) -> Optional[Dict]`

**역할:** 시즌 설정 로딩 (자동 캐시 갱신)

**입력:**
- `excel_path`: Excel 파일 경로
- `json_path`: JSON 캐시 파일 경로

**출력:**
- 시즌 설정 딕셔너리 또는 None

**동작:**
1. Excel 파일 존재 확인
2. Excel mtime vs JSON mtime 비교
3. Excel이 더 최신이면 JSON 재생성
4. JSON 로딩 및 반환

### 2. `parse_excel_to_config(excel_path) -> Dict`

**역할:** Excel 파일을 JSON 구조로 변환

**입력:**
- `excel_path`: Excel 파일 경로

**출력:**
- 시즌 설정 딕셔너리

**동작:**
1. Excel 시트 읽기 (TYPE_PRESETS, SEASON_MASTER, KEYWORDS)
2. JSON 구조로 변환
3. 타입별 기본값 적용
4. 시즌별 키워드 매핑

### 3. `filter_products_by_season(products, season_config, current_date) -> tuple`

**역할:** 상품 리스트를 시즌 필터로 필터링

**입력:**
- `products`: 상품 리스트
- `season_config`: 시즌 설정 딕셔너리
- `current_date`: 현재 날짜 (기본값: 오늘)

**출력:**
- `(filtered_products, excluded_count, excluded_seasons)`

**동작:**
1. 각 상품에 대해 시즌 감지
2. 시즌 유효성 검사
3. 유효한 시즌이 있으면 통과, 없으면 제외

### 4. `get_products_for_upload(..., season_config=None) -> List[Dict]`

**역할:** 업로드용 상품 조회 (시즌 필터링 포함)

**입력:**
- `category`: 카테고리명
- `sheet_name`: 시트명
- `business_number`: 사업자번호
- `status`: 상품 상태
- `exclude_assigned`: 이미 배정된 상품코드 제외 여부
- `season_config`: 시즌 필터 설정 (None이면 자동 로드)

**출력:**
- 업로드 가능한 상품 리스트

**동작:**
1. 시즌 필터 설정 로드 (없으면 자동 로드)
2. 카테고리로 상품 조회
3. 시즌 필터링 적용
4. 상품조합 조회 및 할당 정보 확인
5. 사용 가능한 조합 반환

---

## 주의사항

### 1. 필터링 순서

**올바른 순서:**
```
1. 상품 조회 (카테고리 기준)
2. 시즌 필터링 적용 ← 여기서 필터링
3. 상품조합 생성/조회
4. 마켓별 출력제한 기록 확인
```

**잘못된 순서:**
```
1. 상품 조회
2. 상품조합 생성
3. 시즌 필터링 적용 ← 너무 늦음!
```

### 2. 자동 캐시 갱신

**장점:**
- Excel만 수정하면 자동 반영
- "설정 저장" 버튼 불필요

**주의:**
- Excel 파일이 열려있으면 mtime이 정확하지 않을 수 있음
- Excel 파싱 실패 시 정책 결정 필요 (이전 캐시 사용 vs 강제 중단)

### 3. 성능 고려

**최적화:**
- JSON 캐시 사용으로 Excel 파싱 최소화
- 시즌 필터링은 메모리에서 수행 (DB 쿼리 최소화)
- 배치 처리 고려 (대량 상품 처리 시)

### 4. 에러 처리

**시나리오:**
1. Excel 파일 없음 → JSON 캐시 사용 또는 필터링 건너뜀
2. Excel 파싱 실패 → 이전 JSON 캐시 사용 또는 필터링 건너뜀
3. JSON 로딩 실패 → 필터링 건너뜀

**정책:**
- 필터링 실패 시 전체 프로세스 중단하지 않음
- 로그로 경고 메시지 출력
- 사용자에게 알림

---

## 구현 체크리스트

### Phase 1: 핵심 기능

- [ ] `database/season_filter_loader.py` 생성
  - [ ] `load_season_config()` 함수 구현
  - [ ] `parse_excel_to_config()` 함수 구현
  - [ ] mtime 기반 자동 캐시 갱신
  - [ ] 에러 처리

- [ ] `db_handler.py` 수정
  - [ ] `_load_season_config()` 메서드 추가
  - [ ] `get_products_for_upload()`에 시즌 필터링 통합
  - [ ] 필터링 순서 확인

- [ ] `main_window.py` 수정
  - [ ] `_run_export_for_upload()`에 시즌 필터 설정 로드
  - [ ] `get_products_for_upload()` 호출 시 season_config 전달
  - [ ] 로그 출력

- [ ] 테스트
  - [ ] Excel → JSON 컴파일 테스트
  - [ ] 자동 캐시 갱신 테스트
  - [ ] 시즌 필터링 적용 테스트
  - [ ] 에러 처리 테스트

### Phase 2: 고급 기능 (선택)

- [ ] 점수제 시즌 감지
- [ ] PREP 기간 처리
- [ ] UI 통합 (시즌 필터 설정 버튼)
- [ ] 시즌 필터 통계

---

## 참고 문서

- `시즌필터링_설계안.md`: 기본 설계
- `시즌필터링_개선안_검토.md`: 개선안 검토 (Excel+JSON 이중 구조, 자동 캐시 등)
- `시즌필터링_GUI_활용방안.md`: GUI 활용 방안 (하이브리드 방식 추천)

---

## 다음 단계

1. **설계 검토**: 이 문서를 검토하고 수정사항 확인
2. **구현 시작**: Phase 1부터 단계적으로 구현
3. **테스트**: 각 단계마다 테스트 수행
4. **문서화**: 구현 완료 후 사용 가이드 작성

