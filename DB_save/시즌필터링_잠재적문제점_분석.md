# 시즌 필터링 잠재적 문제점 분석

## 발견된 문제점

### ✅ 정책 확인: 시즌별 exclude 키워드 미사용 (의도된 동작)

**현재 코드** (`filter_products_by_season: 5574-5594줄`):
```python
if season_type == "EVENT":
    # ACTIVE 기간에 공통 제외 키워드 체크
    common_exclude_keywords = season_config.get("settings", {}).get("common_exclude_keywords", [])
    
    # 시즌별 exclude 키워드는 사용하지 않음 (의도된 정책)
```

**정책 확인**:
- ✅ **시즌별 exclude 키워드는 사용하지 않음** (시즌별 키워드는 모두 include만 사용)
- ✅ **공통 제외 키워드만 사용** (환경설정에서 관리)
- ✅ **Event 타입 ACTIVE 기간에만 공통 제외 키워드 적용**

**결론**: 현재 구현이 의도한 정책과 일치함 ✅

---

### 🟡 문제 2: 제외 사유 기록 로직의 불일치

**현재 코드** (`filter_products_by_season: 5634-5648줄`):
```python
# 제외된 시즌 기록 (각 시즌별로 정확한 사유 기록)
for season_id, score in detected_seasons:
    season_info = next((s for s in season_config.get("seasons", []) if s["id"] == season_id), None)
    season_name = season_info.get("name", season_id) if season_info else season_id
    
    if season_id not in excluded_seasons:
        excluded_seasons[season_id] = {'count': 0, 'reason': '', 'name': season_name}
    excluded_seasons[season_id]['count'] += 1
    
    # 제외 사유 설정
    if not excluded_seasons[season_id]['reason']:
        if season_id in season_reasons:
            excluded_seasons[season_id]['reason'] = season_reasons[season_id]
        else:
            excluded_seasons[season_id]['reason'] = f"{season_name}(시즌 기간 외 또는 점수 부족)"
```

**문제점**:
- `season_reasons` 딕셔너리는 각 시즌별 제외 사유를 저장
- 하지만 여러 상품이 같은 시즌에 속하면, 첫 번째 상품의 사유만 기록됨
- 같은 시즌이 여러 사유로 제외될 수 있는데, 마지막 사유만 기록됨

**예시**:
- 상품1: "크리스마스 트리" → 크리스마스 시즌 (EXPIRED)
- 상품2: "크리스마스 선물세트" → 크리스마스 시즌 (제외 키워드)
- **현재**: 크리스마스 시즌의 제외 사유가 하나로만 기록됨

**수정 필요**: 제외 사유를 좀 더 일반적으로 표현하거나, 여러 사유를 병합

---

### 🟡 문제 3: 여러 시즌에 속하는 상품 처리

**현재 코드** (`filter_products_by_season: 5554-5604줄`):
```python
for season_id, score in detected_seasons:
    # ...
    if validity == "ACTIVE":
        score_min = season_info.get("score_min", 1)
        if score >= score_min:
            is_valid = True
            valid_season_id = season_id
            break  # 첫 번째 유효한 시즌을 찾으면 중단
```

**문제점**:
- 상품이 여러 시즌에 속할 수 있음
- 첫 번째 유효한 시즌을 찾으면 바로 break
- 점수가 높은 순서로 정렬되어 있으므로, 점수가 높은 시즌 우선 선택됨

**예시**:
- 상품: "겨울 스키 장갑" 
- 감지된 시즌:
  - 한파 (점수: 5점) - ACTIVE
  - 겨울스포츠 (점수: 3점) - ACTIVE
- **현재**: 한파 시즌만 기록됨
- **의도**: 둘 다 기록해야 하는가? 아니면 하나만 선택하는 것이 맞는가?

**수정 필요**: 
- 현재 로직이 의도한 동작인지 확인 필요
- 만약 여러 시즌 모두 기록해야 한다면 로직 수정 필요

---

### 🟡 문제 4: SOURCING 기간 제외 키워드 무시의 문제

**현재 코드** (`filter_products_by_season: 5608-5612줄`):
```python
elif validity == "SOURCING":
    # 소싱 기간: 이미 가공 완료된 상품이므로 제외
    season_reasons[season_id] = f"{season_name}(소싱 기간 - 이미 가공 완료)"
```

**문제점**:
- SOURCING 기간에는 제외 키워드를 무시한다고 했지만
- SOURCING 기간 상품은 모두 제외되므로 제외 키워드 체크가 의미가 없음
- 하지만 로직상 SOURCING 기간에 제외 키워드가 있어도 제외되지 않는 것처럼 보임

**예시**:
- 상품: "발렌타인 초콜릿 포장세트"
- 시즌: 발렌타인데이 (SOURCING 기간)
- 제외 키워드: "포장"
- **현재**: SOURCING 기간이므로 제외됨 (제외 키워드와 무관)
- **의도**: 맞음 (SOURCING 기간이면 무조건 제외)

**결론**: 현재 로직이 맞음 (SOURCING 기간은 무조건 제외)

---

### 🟢 문제 5: 카테고리명 검색의 과도한 매칭 가능성

**현재 코드** (`_detect_seasons_from_product: 5673-5677줄`):
```python
search_text = product_name
if category_name:
    search_text = f"{product_name} {category_name}"

if not case_sensitive:
    search_text = search_text.lower()
```

**문제점**:
- 카테고리명 전체를 검색 텍스트에 포함
- 카테고리명이 길고 다양한 키워드를 포함할 수 있음
- 예: "홈/리빙>인테리어소품>장식품>크리스마스장식"
- "크리스마스장식"이 카테고리명에 있으면 크리스마스 시즌으로 감지됨

**예시**:
- 상품명: "일반 벽걸이 액자"
- 카테고리명: "홈/리빙>인테리어소품>장식품>크리스마스장식"
- **현재**: 크리스마스 시즌으로 감지될 수 있음
- **의도**: 카테고리명의 키워드도 신뢰할 수 있는가?

**수정 필요**: 
- 카테고리명 검색이 의도된 동작인지 확인
- 만약 카테고리명을 신뢰하지 않는다면 제거

---

## 권장 수정 사항

### 1. 시즌별 exclude 키워드 체크 추가

```python
if validity == "ACTIVE":
    season_type = season_info.get("type", "").strip().upper()
    
    if season_type == "EVENT":
        # 공통 제외 키워드 체크
        common_exclude_keywords = season_config.get("settings", {}).get("common_exclude_keywords", [])
        
        # 시즌별 제외 키워드도 체크 (추가)
        season_exclude_keywords = []
        keywords = season_info.get("keywords", {})
        for kw_info in keywords.get("exclude", []):
            kw = kw_info.get("keyword", "")
            if not case_sensitive:
                kw = kw.lower()
            season_exclude_keywords.append(kw)
        
        # 모든 제외 키워드 결합
        all_exclude_keywords = common_exclude_keywords + season_exclude_keywords
        
        # 제외 키워드 확인
        has_exclude_keyword = False
        for kw in all_exclude_keywords:
            if isinstance(kw, dict):
                kw_str = kw.get("keyword", kw.get("key", "")).lower()
            else:
                kw_str = str(kw).lower()
            
            if kw_str and kw_str in search_text_for_exclude:
                has_exclude_keyword = True
                break
        
        if has_exclude_keyword:
            season_reasons[season_id] = f"{season_name}(제외 키워드 매칭 - Event 타입)"
            continue
```

### 2. 제외 사유 기록 로직 개선

제외된 시즌의 사유를 더 명확하게 기록:
- 여러 사유가 있을 경우 가장 중요한 사유 우선 기록
- 또는 여러 사유를 모두 기록

### 3. 카테고리명 검색 정책 명확화

- 카테고리명 검색이 의도된 동작인지 확인
- 만약 제거한다면 코드 수정
- 만약 유지한다면 카테고리명의 신뢰성 검증 추가

---

## 검증 필요 사항

다음 사항들을 실제 데이터로 테스트하여 확인해야 합니다:

1. ✅ 시즌별 exclude 키워드가 제대로 작동하는지
2. ✅ 여러 시즌에 속하는 상품이 올바르게 처리되는지
3. ✅ 카테고리명 검색이 과도한 매칭을 일으키지 않는지
4. ✅ 제외 사유가 정확하게 기록되는지

