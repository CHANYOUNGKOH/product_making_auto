# 상품조합 순환식 변경 방안

## 개요

현재 상품코드 조합이 1회성으로 소진되는 구조를 순환식으로 변경하여, 스토어 현황과 맞지 않을 때 재사용 가능하도록 개선합니다.

---

## 현재 구조의 문제점

### 현재 방식 (1회성 소진)
- `combination_assignments` 테이블에 조합이 기록되면 재사용 불가
- 조합을 모두 소진하면 더 이상 사용할 수 없는 DB가 됨
- 실제 스토어에 업로드되지 않았어도 조합이 소진됨
- 타 마켓에 업로드되거나 업로드 불가능한 경우 조합이 낭비됨

### 변경하려는 방식 (순환식)
- 조합을 소진하는 개념이 아닌, 순환식으로 제공
- URL (누끼/믹스)이 있으면 번갈아가면서 제공
- 상품명은 있는 순서대로 순차적으로 제공
- 마지막까지 제공했으면 다시 처음부터 제공
- URL이 없으면 당연히 못 내보냄

---

## 변경 시 고려사항

### 1. 기존 출고 내역 리셋

**옵션 A: 기존 내역 유지 (권장)**
- `combination_assignments` 테이블은 참조용으로 유지
- 스토어별 마지막 사용 조합 인덱스를 추적
- 다음 출고 시 마지막 인덱스 이후부터 제공
- **장점**: 기존 출고 이력 유지, 점진적 전환 가능

**옵션 B: 기존 내역 리셋**
- `combination_assignments` 테이블 초기화 또는 삭제
- 모든 조합을 처음부터 다시 제공
- **장점**: 간단한 구현
- **단점**: 기존 출고 이력 손실, 중복 업로드 위험

### 2. ST4_최종상품명 및 URL 업데이트 처리

**문제 시나리오**:
1. 기존 조합 인덱스 0: 상품명 A, 믹스URL 1
2. 상품 재가공 후: 상품명 A가 변경되거나, 믹스URL 1이 업데이트됨
3. 조합 인덱스가 재생성되거나 기존 조합과 매칭이 안 될 수 있음

**해결 방안**:
- `combination_index`는 변경되지 않음 (상품코드별 고유 인덱스)
- `product_combinations` 테이블에서 조합 정보를 항상 최신으로 조회
- `combination_assignments`에는 인덱스만 저장하고, 실제 조합 정보는 조회 시 가져옴
- **안전**: URL이나 상품명이 업데이트되어도 인덱스로 매칭 가능

### 3. ST2_JSON 업데이트

- `product_combinations` 테이블에 `st2_json` 저장
- 조합 조회 시 최신 정보 사용
- **문제 없음**: 조합 테이블이 업데이트되면 자동으로 반영

---

## 구현 방안

### 방안 1: 기존 내역 유지 + 순환 로직 추가 (권장)

#### 1.1 데이터베이스 구조 변경

**새로운 테이블 추가**: `store_combination_state`
```sql
CREATE TABLE IF NOT EXISTS store_combination_state (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    sheet_name TEXT NOT NULL,
    business_number TEXT NOT NULL,
    product_code TEXT NOT NULL,
    last_used_combination_index INTEGER DEFAULT 0,
    last_used_url_type TEXT DEFAULT 'mix',  -- 'mix', 'nukki', 'name_only'
    last_used_at TEXT DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(sheet_name, business_number, product_code)
)
```

**역할**:
- 각 스토어별로 마지막 사용한 조합 인덱스 추적
- 다음 출고 시 이 인덱스 이후부터 제공
- URL 타입도 추적하여 누끼/믹스 번갈아가면서 제공

#### 1.2 조합 선택 로직 변경

**현재 로직** (`db_handler.py:743-807`):
```python
# 사용된 인덱스 제외
used_indices = sheet_used_combinations.get(product_code, set())
if used_indices:
    # NOT IN 사용하여 제외
```

**변경된 로직**:
```python
def get_next_combination_for_store(
    cursor, 
    product_code: str, 
    sheet_name: str, 
    business_number: str,
    exclude_assigned: bool = False
) -> Dict:
    """
    스토어별 다음 조합 반환 (순환식)
    
    순서:
    1. 스토어별 마지막 사용 인덱스 조회
    2. 해당 인덱스 이후의 조합 조회
    3. URL 타입별로 번갈아가면서 제공 (누끼/믹스)
    4. 상품명 순차적으로 제공
    5. 마지막까지 가면 처음부터 다시
    """
    # 1. 스토어별 마지막 사용 상태 조회
    cursor.execute("""
        SELECT last_used_combination_index, last_used_url_type
        FROM store_combination_state
        WHERE sheet_name = ? AND business_number = ? AND product_code = ?
    """, (sheet_name, business_number, product_code))
    
    row = cursor.fetchone()
    if row:
        last_index, last_url_type = row
        start_index = last_index + 1
        last_url_type = last_url_type or 'mix'
    else:
        start_index = 0
        last_url_type = 'mix'
    
    # 2. 조합 조회 (순환식)
    # 2-1. start_index 이후의 모든 조합 조회
    cursor.execute("""
        SELECT * FROM product_combinations
        WHERE product_code = ?
        AND combination_index >= ?
        ORDER BY combination_index ASC
    """, (product_code, start_index))
    
    candidates = [dict(row) for row in cursor.fetchall()]
    
    # 2-2. start_index 이전 조합도 조회 (순환을 위해)
    if not candidates or (len(candidates) == 1 and start_index > 0):
        cursor.execute("""
            SELECT * FROM product_combinations
            WHERE product_code = ?
            AND combination_index < ?
            ORDER BY combination_index ASC
        """, (product_code, start_index))
        candidates.extend([dict(row) for row in cursor.fetchall()])
    
    # 3. URL 타입별 필터링 및 순환
    # 누끼/믹스 번갈아가면서 제공
    url_type_priority = ['nukki', 'mix'] if last_url_type == 'mix' else ['mix', 'nukki']
    
    # 3-1. URL이 있는 조합만 필터링
    valid_combinations = []
    for combo in candidates:
        url_type = combo.get('url_type', 'mix')
        nukki_url = combo.get('nukki_url', '') or ''
        mix_url = combo.get('mix_url', '') or ''
        
        # URL이 없으면 제외
        if url_type == 'nukki' and not nukki_url:
            continue
        if url_type == 'mix' and not mix_url:
            continue
        if url_type == 'name_only':
            # 상품명만 있는 경우도 포함
            pass
        
        valid_combinations.append(combo)
    
    # 3-2. URL 타입 우선순위로 정렬
    def get_url_type_priority(combo):
        url_type = combo.get('url_type', 'mix')
        if url_type in url_type_priority:
            return url_type_priority.index(url_type)
        return 999  # name_only 등은 뒤로
    
    valid_combinations.sort(key=lambda x: (get_url_type_priority(x), x.get('combination_index', 0)))
    
    # 4. 첫 번째 유효한 조합 선택
    if valid_combinations:
        selected = valid_combinations[0]
        
        # 5. 상태 업데이트 (트랜잭션 처리 필요)
        cursor.execute("""
            INSERT OR REPLACE INTO store_combination_state
            (sheet_name, business_number, product_code, 
             last_used_combination_index, last_used_url_type, 
             last_used_at, updated_at)
            VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        """, (
            sheet_name, 
            business_number, 
            product_code,
            selected.get('combination_index', 0),
            selected.get('url_type', 'mix')
        ))
        
        return selected
    
    return None  # 사용 가능한 조합 없음
```

#### 1.3 전체 시트 동일 조합 추적 유지

**기존 로직 유지**:
- `global_used_combinations`로 전체 시트에서 동일 조합 추적
- 같은 조합은 다른 스토어에서도 사용 불가

**순환 로직과의 차이**:
- 순환 로직: 같은 스토어 내에서 순환
- 전체 시트 추적: 다른 스토어와는 중복 방지

**조합**:
- 스토어별로 마지막 사용 인덱스를 추적하여 순환 제공
- 하지만 전체 시트에서 이미 사용된 조합은 제외
- → 새로운 조합이 계속 생성되면 순환 가능
- → 모든 조합이 사용되면 더 이상 제공 불가 (현재와 동일)

**개선 방안**:
- 조합이 모두 소진되면 `combination_assignments`를 참조하여 오래된 조합부터 재사용
- 또는 `exclude_assigned=False` 옵션 사용 시 순환 가능

#### 1.4 exclude_assigned 옵션 처리

**exclude_assigned=True (새로운 DB만 출력)**:
- 스토어별로 이미 사용한 상품코드는 제외
- 순환 로직과 충돌할 수 있음
- **해결**: 순환 로직을 우선 적용, exclude_assigned는 다른 목적으로 사용

**exclude_assigned=False (재출력 가능)**:
- 순환 로직과 잘 맞음
- 스토어별로 마지막 사용 인덱스 이후부터 제공

---

### 방안 2: 기존 내역 리셋 + 순환 로직 (간단하지만 위험)

#### 2.1 combination_assignments 테이블 초기화

```sql
-- 백업 후 초기화
DELETE FROM combination_assignments;
```

#### 2.2 순환 로직 구현 (방안 1과 동일)

**장점**: 구현 간단
**단점**: 기존 출고 이력 손실, 중복 업로드 위험

---

## 구현 단계

### 1단계: 백업 복사본 생성 (필수)

```python
# 백업 스크립트
import shutil
import os
from datetime import datetime

def backup_database(db_path: str):
    """데이터베이스 백업"""
    backup_dir = os.path.join(os.path.dirname(db_path), "backups")
    os.makedirs(backup_dir, exist_ok=True)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = os.path.join(backup_dir, f"products_backup_{timestamp}.db")
    
    shutil.copy2(db_path, backup_path)
    print(f"백업 완료: {backup_path}")
    return backup_path
```

### 2단계: 스크립트 파일 백업

```python
# 현재 스크립트 복사
import shutil

# db_handler.py 백업
shutil.copy2(
    "database/db_handler.py",
    f"database/db_handler_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.py"
)

# main_window.py 백업
shutil.copy2(
    "ui/main_window.py",
    f"ui/main_window_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.py"
)
```

### 3단계: 데이터베이스 마이그레이션

```python
def migrate_to_circular_combinations(db_handler):
    """순환식 조합 구조로 마이그레이션"""
    cursor = db_handler.conn.cursor()
    
    # 1. 새 테이블 생성
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS store_combination_state (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sheet_name TEXT NOT NULL,
            business_number TEXT NOT NULL,
            product_code TEXT NOT NULL,
            last_used_combination_index INTEGER DEFAULT 0,
            last_used_url_type TEXT DEFAULT 'mix',
            last_used_at TEXT DEFAULT CURRENT_TIMESTAMP,
            updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(sheet_name, business_number, product_code)
        )
    """)
    
    # 2. 기존 combination_assignments에서 상태 초기화 (선택적)
    # 옵션 A: 기존 내역을 기반으로 초기 상태 설정
    cursor.execute("""
        INSERT INTO store_combination_state
        (sheet_name, business_number, product_code, last_used_combination_index, last_used_url_type)
        SELECT 
            ca.sheet_name,
            ca.business_number,
            ca.product_code,
            MAX(ca.combination_index) as last_index,
            COALESCE(
                (SELECT pc.url_type 
                 FROM product_combinations pc 
                 WHERE pc.product_code = ca.product_code 
                 AND pc.combination_index = MAX(ca.combination_index)
                 LIMIT 1),
                'mix'
            ) as last_url_type
        FROM combination_assignments ca
        GROUP BY ca.sheet_name, ca.business_number, ca.product_code
    """)
    
    # 옵션 B: 모두 0부터 시작 (초기화)
    # 위 쿼리 실행 안 함
    
    db_handler.conn.commit()
    print("마이그레이션 완료")
```

### 4단계: 코드 수정

#### 4.1 db_handler.py 수정

**변경 파일**: `database/db_handler.py`

**주요 변경 사항**:
1. `get_products_for_upload` 메서드 수정
   - 기존: 사용된 인덱스 제외
   - 변경: 순환 로직 적용

2. 새로운 메서드 추가
   - `get_next_combination_for_store`: 스토어별 다음 조합 반환

#### 4.2 main_window.py 수정

**변경 파일**: `ui/main_window.py`

**주요 변경 사항**:
1. 조합 선택 로직 수정 (6017-6052 라인)
   - 기존: `global_used_combinations` 체크만
   - 변경: 순환 로직 + `global_used_combinations` 체크

---

## URL 및 상품명 업데이트 처리

### 문제 시나리오

**시나리오 1: 상품명 변경**
```
기존: combination_index=0, product_name="상품명 A"
변경: combination_index=0, product_name="상품명 A (개선)"
```
**처리**: 
- `product_combinations` 테이블이 업데이트되면 자동으로 반영
- `store_combination_state`는 인덱스만 추적하므로 문제 없음

**시나리오 2: URL 변경**
```
기존: combination_index=0, mix_url="url1", nukki_url=""
변경: combination_index=0, mix_url="url1_new", nukki_url="url2"
```
**처리**:
- `product_combinations` 테이블이 업데이트되면 자동으로 반영
- URL 타입도 업데이트 가능 (mix → nukki 등)
- 순환 로직에서 URL 존재 여부 체크하므로 문제 없음

**시나리오 3: 조합 인덱스 재생성**
```
기존: combination_index=0,1,2,3
재가공 후: combination_index=0,1,2 (3 삭제됨)
```
**처리**:
- `store_combination_state`의 `last_used_combination_index`가 존재하지 않는 인덱스를 가리킬 수 있음
- 순환 로직에서 존재하지 않는 인덱스 발견 시 0부터 시작하도록 처리

**안전 처리 코드**:
```python
# 조합 인덱스 검증
cursor.execute("""
    SELECT MAX(combination_index) as max_index
    FROM product_combinations
    WHERE product_code = ?
""", (product_code,))

max_index_row = cursor.fetchone()
max_index = max_index_row[0] if max_index_row and max_index_row[0] is not None else -1

if last_index > max_index:
    # 존재하지 않는 인덱스를 가리키면 0부터 시작
    start_index = 0
else:
    start_index = last_index + 1
```

---

## 테스트 방안

### 1. 단위 테스트

```python
def test_circular_combination_logic():
    """순환 로직 테스트"""
    # 1. 조합 3개 생성 (인덱스 0,1,2)
    # 2. 스토어 A에서 조합 0 사용
    # 3. 다음 조합 요청 시 조합 1 반환 확인
    # 4. 조합 2 사용 후
    # 5. 다음 조합 요청 시 조합 0 반환 확인 (순환)
    pass
```

### 2. 통합 테스트

```python
def test_url_type_alternation():
    """URL 타입 번갈아가기 테스트"""
    # 1. 믹스 URL 조합, 누끼 URL 조합 각각 생성
    # 2. 첫 번째 조합 사용 (믹스)
    # 3. 다음 조합 요청 시 누끼 반환 확인
    # 4. 다음 조합 요청 시 믹스 반환 확인
    pass
```

### 3. 업데이트 테스트

```python
def test_combination_update():
    """조합 업데이트 시 처리 테스트"""
    # 1. 조합 0 사용
    # 2. 조합 0의 상품명/URL 업데이트
    # 3. 다음 조합 요청 시 업데이트된 정보 반환 확인
    pass
```

---

## 롤백 방안

### 문제 발생 시

1. **백업 복원**
   ```python
   # 백업 파일로 복원
   shutil.copy2(backup_path, db_path)
   ```

2. **스크립트 복원**
   ```python
   # 백업 스크립트로 복원
   shutil.copy2(
       f"database/db_handler_backup_{timestamp}.py",
       "database/db_handler.py"
   )
   ```

3. **테이블 삭제** (필요시)
   ```sql
   DROP TABLE IF EXISTS store_combination_state;
   ```

---

## 권장 사항

### ✅ 권장 방식: 방안 1 (기존 내역 유지)

**이유**:
1. 기존 출고 이력 유지로 안전성 확보
2. 점진적 전환 가능
3. 문제 발생 시 롤백 용이
4. 기존 로직과 충돌 최소화

### 구현 순서

1. ✅ **백업 생성** (DB + 스크립트)
2. ✅ **마이그레이션 스크립트 작성 및 테스트**
3. ✅ **새 테이블 생성 및 데이터 마이그레이션**
4. ✅ **순환 로직 구현** (db_handler.py)
5. ✅ **메인 로직 수정** (main_window.py)
6. ✅ **테스트** (단위 + 통합)
7. ✅ **점진적 적용** (일부 스토어만 먼저 테스트)

### 주의사항

1. ⚠️ **기존 `combination_assignments` 테이블은 유지** (참조용)
2. ⚠️ **전체 시트 동일 조합 추적 로직 유지** (중복 방지)
3. ⚠️ **URL 업데이트 시 인덱스 검증 필수**
4. ⚠️ **트랜잭션 처리 필수** (상태 업데이트 시)

---

---

## 구현 완료 사항

### ✅ 완료된 작업

1. **백업 생성** ✅
   - 데이터베이스 파일 백업
   - 스크립트 파일 백업 (`database/db_handler.py`, `ui/main_window.py`)

2. **마이그레이션 완료** ✅
   - `store_combination_state` 테이블 생성
   - 107,341개 스토어의 초기 상태 설정
   - 기존 `combination_assignments` 데이터 기반으로 초기화

3. **코드 수정 완료** ✅
   - `db_handler.py`: `get_next_combination_for_store()` 메서드 추가
   - `main_window.py`: 조합 선택 로직을 순환 로직으로 변경

---

## URL이 없는 경우 처리 방식

### 기존 방식
- URL이 없는 조합(`name_only`)도 포함하여 순차적으로 제공
- URL 타입이 'mix'인데 mix_url이 없거나, 'nukki'인데 nukki_url이 없으면 제외
- `name_only`는 URL 없이 상품명만 제공

### 변경 후 방식 (순환식)
- **URL이 있는 조합**: 누끼/믹스 번갈아가면서 제공
- **URL이 없는 조합(`name_only`)**: 상품명만 순차적으로 제공
- 조합별로 제공되므로 URL과 상품명이 함께 제공됨
- 마지막 사용 인덱스 이후부터 순차 제공, 마지막까지 가면 처음부터 다시

### 처리 로직 상세

1. **조합 필터링**
   - `url_type='nukki'`이고 `nukki_url`이 있으면 → 포함
   - `url_type='mix'`이고 `mix_url`이 있으면 → 포함
   - `url_type='name_only'` → 포함 (URL 없이 상품명만)
   - `url_type='nukki'`인데 `nukki_url`이 없으면 → 제외
   - `url_type='mix'`인데 `mix_url`이 없으면 → 제외

2. **순서 정렬**
   - URL 타입 우선순위: 마지막 사용 URL 타입의 반대 타입 우선
     - 마지막이 'mix'이면 → 'nukki' → 'mix' → 'name_only' 순서
     - 마지막이 'nukki'이면 → 'mix' → 'nukki' → 'name_only' 순서
   - 같은 URL 타입 내에서는 `combination_index` 오름차순

3. **순환 로직**
   - 마지막 사용 인덱스 이후부터 제공
   - 마지막까지 가면 처음부터 다시 순환

### 기존 방식과의 차이점

| 항목 | 기존 방식 | 변경 후 방식 |
|------|----------|------------|
| URL/상품명 처리 | 조합별로 함께 제공 | 조합별로 함께 제공 (동일) |
| URL 번갈아가기 | 없음 (인덱스 순서대로) | 누끼/믹스 번갈아가면서 제공 |
| name_only 처리 | 포함 (순차 제공) | 포함 (순차 제공, 동일) |
| 순환 방식 | 없음 (1회성 소진) | 있음 (순환식) |

**결론**: 
- ✅ URL과 상품명은 여전히 **조합별로 함께 제공**됨 (별도가 아님)
- ✅ `name_only`는 기존과 동일하게 **순차적으로 제공**됨
- ✅ 문제 없음: 기존 방식과 동일하게 조합 단위로 처리됨

---

## URL 및 상품명 업데이트 처리

### 조합 인덱스 검증
- `store_combination_state`의 `last_used_combination_index`가 존재하지 않는 인덱스를 가리킬 수 있음
- 순환 로직에서 최대 인덱스를 확인하여, 존재하지 않는 인덱스 발견 시 0부터 시작

**안전 처리 코드**:
```python
# 조합 인덱스 검증
cursor.execute("""
    SELECT MAX(combination_index) as max_index
    FROM product_combinations
    WHERE product_code = ?
""", (product_code,))

max_index_row = cursor.fetchone()
max_index = max_index_row[0] if max_index_row and max_index_row[0] is not None else -1

if last_index > max_index:
    # 존재하지 않는 인덱스를 가리키면 0부터 시작
    start_index = 0
else:
    start_index = last_index + 1
```

### 상품명/URL 업데이트 시
- `product_combinations` 테이블이 업데이트되면 자동으로 반영
- `store_combination_state`는 인덱스만 추적하므로 문제 없음
- 조합 조회 시 항상 최신 정보 사용

---

## 테스트 권장 사항

1. **작은 규모로 테스트**
   - 소수의 스토어만 선택하여 데이터 출고 테스트
   - 순환 로직이 정상 작동하는지 확인

2. **URL 타입별 테스트**
   - 누끼 URL만 있는 조합
   - 믹스 URL만 있는 조합
   - 둘 다 있는 조합
   - name_only 조합

3. **순환 테스트**
   - 여러 번 출고하여 순환되는지 확인
   - 마지막 조합 이후 첫 번째 조합이 제공되는지 확인

---

## 다음 단계

1. ✅ 백업 복사본 생성 완료
2. ✅ 마이그레이션 완료
3. ✅ 코드 수정 완료
4. ⏳ 테스트 진행

테스트 진행 후 문제가 발견되면 알려주세요!
