# 데이터 출고 필터링 구조 통합 문서

## 개요

마켓 업로드용 데이터 출고 과정에서 적용되는 필터링 구조와 동작 방식을 정리한 문서입니다.

---

## 전체 필터링 순서

데이터 출고 시 다음 순서로 필터링이 적용됩니다:

```
[1단계] 사용자 옵션 설정
  ├─ 새로운 DB만 출력 (exclude_assigned)
  ├─ 시즌 필터링 활성화 여부 (season_filter_enabled)
  ├─ 상품코드 필터 모드 (none/exclude/include)
  ├─ 상품코드 필터 목록 (product_code_filter_codes)
  ├─ 스토어별 수량 제한 (total_quantity_limit)
  └─ 등록된 상품수량 제한 (store_registered_limit)
    ↓
[2단계] 시트별/스토어별 그룹화
  ├─ 같은 시트명끼리 그룹화 (markets_by_sheet)
  ├─ 시트별로 순차 처리
  └─ 스토어별로 순차 처리
    ↓
[3단계] 사전 조회 및 캐싱 (성능 최적화)
  ├─ 시트별 사용된 조합 조회 (sheet_used_combinations_cache)
  ├─ 스토어별 사용된 상품코드 조회 (store_used_product_codes_cache)
  └─ market_id 캐싱 (시트별로 한 번만)
    ↓
[4단계] 카테고리별 상품 조회 (DB 쿼리)
  ├─ 카테고리명 LIKE 패턴 매칭
  ├─ product_status = 'ACTIVE'
  └─ product_names_json 존재 여부 확인
    ↓
[5단계] 상품코드 필터링 (Python 레벨)
  ├─ exclude 모드: 입력한 상품코드 제외
  ├─ include 모드: 입력한 상품코드만 포함
  └─ none 모드: 필터링 안 함
    ↓
[6단계] 시즌 필터링 (Python 레벨, 선택적)
  ├─ 시즌 설정 파일 로드 (캐싱 적용)
  ├─ 시즌 키워드 감지 (상품명 + 카테고리명)
  ├─ 시즌 유효성 확인 (ACTIVE/SOURCING/EXPIRED)
  ├─ 예외단어 체크 (Event 타입 ACTIVE만)
  └─ 최종 포함/제외 결정
    ↓
[7단계] 조합 조회 (각 상품코드별)
  ├─ exclude_assigned 체크 (스토어별 이미 사용한 상품코드 제외)
  ├─ product_combinations 테이블에서 조회
  ├─ 이미 사용된 조합 인덱스 제외 (sheet_used_combinations)
  └─ 사용 가능한 조합만 반환 (LIMIT 100)
    ↓
[8단계] 상품코드별 그룹화
  ├─ all_products_by_code에 그룹화
  └─ 카테고리 순서 유지
    ↓
[9단계] 우선순위 정렬 (exclude_assigned=True + 수량 제한 있을 때)
  ├─ 출고된 적 없는 상품코드를 먼저 처리
  └─ 출고된 적 있는 상품코드는 나중에 처리
    ↓
[10단계] 상품코드별 처리 (루프)
    ├─ 등록된 상품수량 제한 체크 (store_registered_limit)
    ├─ 스토어별 수량 제한 체크 (total_quantity_limit)
    ├─ exclude_assigned 재체크 (스토어별 이미 사용한 상품코드)
    ├─ 전체 시트 동일 조합 추적 (global_used_combinations)
    ├─ exclude_assigned=False일 때 스토어별 조합 체크
    └─ 사용 가능한 조합 찾기
      ↓
[11단계] 최종 조합 할당 및 DB 기록
    ├─ combination_assignments 테이블에 기록 (배치 INSERT)
    ├─ upload_logs 테이블에 기록 (exclude_assigned=True일 때만, 배치 INSERT)
    └─ Excel 파일로 저장
```

---

## 단계별 상세 설명

### 1단계: 사용자 옵션 설정

**위치**: `ui/main_window.py:5206-5243`

#### 1.1 새로운 DB만 출력 (exclude_assigned)

**설명**: 이미 해당 스토어에서 배정받은 상품코드를 제외할지 여부

**옵션**:
- `True`: 스토어별로 이미 사용한 상품코드는 조합 조회 자체를 건너뜀
- `False`: 이미 사용한 상품코드도 포함하여 재출력 가능 (조합만 중복 체크)

**동작**:
- `True`일 때: `combination_assignments` 테이블에서 스토어별 사용한 상품코드 조회 후 제외
- `False`일 때: 이미 사용한 조합만 제외하고, 같은 상품코드의 다른 조합은 사용 가능

**DB 기록**:
- `True`일 때: `upload_logs` 테이블에 기록 (재출력 방지)
- `False`일 때: `upload_logs` 테이블에 기록하지 않음

#### 1.2 시즌 필터링 활성화 여부 (season_filter_enabled)

**설명**: 현재 시즌에 맞는 상품만 자동으로 선택할지 여부

**옵션**:
- `True`: 시즌 필터링 적용 (기본값)
- `False`: 시즌 필터링 미적용 (모든 상품 포함)

**동작**:
- `True`일 때: 시즌 설정 파일을 로드하여 필터링 적용
- `False`일 때: 시즌 필터링 로직을 건너뛰고 모든 상품 포함

#### 1.3 상품코드 필터 모드

**설명**: 특정 상품코드를 필터링할지 여부

**옵션**:
- `none`: 필터링 안 함
- `exclude`: 입력한 상품코드 제외
- `include`: 입력한 상품코드만 포함

**입력 형식**: 텍스트 영역에 쉼표 또는 줄바꿈으로 구분하여 입력

**적용 시점**: 시즌 필터링 전에 적용 (성능 최적화)

#### 1.4 스토어별 수량 제한 (total_quantity_limit)

**설명**: 각 스토어별로 최대 출력 조합 수량 제한

**입력**: 숫자 (예: 100)

**동작**: 각 스토어별로 지정된 수량만큼만 조합 할당

#### 1.5 등록된 상품수량 제한 (store_registered_limit)

**설명**: 스토어 메모에 등록된 상품수량(registered_count)만큼만 출고

**출처**: 스토어 메모에서 `registered_count` 필드 읽기

**동작**: 등록된 상품수량 초과 시 스킵 (0이거나 없으면 제한 없음)

---

### 2단계: 시트별/스토어별 그룹화

**위치**: `ui/main_window.py:5570-5586`

**동작**:
- 선택된 마켓을 `sheet_name` 기준으로 그룹화
- 같은 시트명을 가진 스토어들을 함께 처리
- 시트별로 순차 처리, 스토어별로 순차 처리

**예시**:
```python
markets_by_sheet = {
    "11번가": [스토어1, 스토어2, ...],
    "옥션": [스토어3, 스토어4, ...],
    ...
}
```

---

### 3단계: 사전 조회 및 캐싱 (성능 최적화)

**위치**: `ui/main_window.py:5344-5391`, `ui/main_window.py:5627-5634`

#### 3.1 시트별 사용된 조합 조회 (캐싱)

**위치**: `ui/main_window.py:5344-5358`

**동작**:
- 시트별로 한 번만 조회 (캐싱)
- `combination_assignments` 테이블에서 시트별 사용된 조합 인덱스 조회
- `{product_code: set(combination_indices)}` 형태로 저장

**효과**: 카테고리마다 반복 조회하는 대신 시트별로 한 번만 조회

#### 3.2 스토어별 사용된 상품코드 조회 (캐싱)

**위치**: `ui/main_window.py:5360-5370`

**동작**:
- `exclude_assigned=True`일 때만 조회
- 스토어별로 한 번만 조회 (캐싱)
- `combination_assignments` 테이블에서 스토어별 사용된 상품코드 조회
- `set` 형태로 저장

**효과**: 카테고리마다 반복 조회하는 대신 스토어별로 한 번만 조회

#### 3.3 market_id 캐싱

**위치**: `ui/main_window.py:5627-5634`

**동작**:
- 시트별로 한 번만 조회 (캐싱)
- `markets` 테이블에서 `market_id` 조회
- 시트명을 키로 캐싱

**효과**: 상품마다 반복 조회하는 대신 시트별로 한 번만 조회

---

### 4단계: 카테고리별 상품 조회 (DB 쿼리)

**위치**: `database/db_handler.py:571-600`

**쿼리**:
```sql
SELECT DISTINCT p.상품코드, p.원본상품명, p.ST3_결과상품명, 
       p.ST1_정제상품명, p.카테고리명
FROM products p
WHERE p.카테고리명 LIKE ? 
AND p.product_status = 'ACTIVE'
AND p.product_names_json IS NOT NULL 
AND p.product_names_json != '' 
AND p.product_names_json != '[]'
```

**조건**:
1. **카테고리명 LIKE 패턴 매칭**: 대분류와 중분류로 패턴 생성
   - 예: "홈/리빙>인테리어소품" → `%홈/리빙%>%인테리어소품%`
2. **상품 상태**: `product_status = 'ACTIVE'`
3. **상품명 존재**: `product_names_json`이 존재해야 함

**카테고리 출처**:
- 스토어 메모에 지정된 카테고리 사용
- 스토어 메모에 카테고리가 없으면 오류 메시지 표시

**상품명 우선순위**:
- `원본상품명` > `ST3_결과상품명` > `ST1_정제상품명`

---

### 5단계: 상품코드 필터링 (Python 레벨)

**위치**: `database/db_handler.py:602-629`

**적용 시점**: 시즌 필터링 전에 적용 (성능 최적화)

**모드별 동작**:

#### exclude 모드 (제외)
```python
products_with_info = [
    p for p in products_with_info 
    if p.get("상품코드", "") not in product_code_filter_codes
]
```
- 입력한 상품코드를 제외
- 나머지 상품은 모두 포함

#### include 모드 (포함)
```python
products_with_info = [
    p for p in products_with_info 
    if p.get("상품코드", "") in product_code_filter_codes
]
```
- 입력한 상품코드만 포함
- 나머지 상품은 모두 제외

#### none 모드
- 필터링하지 않음
- 모든 상품 포함

**로그 출력**:
- 필터링 결과 통계 출력 (원본 수, 필터링 후 수, 제외된 수)

---

### 6단계: 시즌 필터링 (Python 레벨, 선택적)

**위치**: `database/db_handler.py:631-724`

**활성화 조건**: `season_filter_enabled=True`이고 시즌 필터링 모듈이 사용 가능할 때

#### 6.1 시즌 설정 파일 로드 (캐싱 적용)

**위치**: `database/db_handler.py:641-650`

**캐싱 방식**:
```python
global _season_config_cache, _season_config_cache_path

cache_path = (excel_path, json_path)
if _season_config_cache is None or _season_config_cache_path != cache_path:
    _season_config_cache = load_season_config(excel_path, json_path)
    _season_config_cache_path = cache_path

season_config = _season_config_cache
```

**효과**: 카테고리마다 반복 로드하는 대신 한 번만 로드 (캐싱)

**파일**:
- Excel: `Season_Filter_Seasons_Keywords.xlsx`
- JSON: `season_filters.json` (캐시 파일)

#### 6.2 시즌 필터링 처리

**위치**: `season_filter_manager_gui.py:filter_products_by_season()`

**처리 순서**:

1. **예외단어 체크** (최우선순위)
   - 상품명 + 카테고리명에서 공통 예외단어 검색
   - 예외단어 매칭 시 `has_exclude_keyword = True`

2. **시즌 감지** (항상 수행)
   - 상품명 + 카테고리명에서 시즌 include 키워드 검색
   - 매칭된 키워드의 가중치 합산하여 점수 계산
   - 각 시즌별 점수 반환

3. **시즌 유효성 확인**
   - 각 감지된 시즌에 대해 현재 날짜 기준으로 상태 확인
   - **ACTIVE**: 출력 가능 기간
   - **SOURCING**: 소싱 기간 (Event 타입만 제외)
   - **EXPIRED**: 시즌 종료 (Event 타입만 제외)

4. **최종 결정**:
   - **유효한 시즌이 있으면**: 포함 (시즌 상품으로 분류)
   - **예외단어 포함 + 모든 시즌 제외**: 포함 (일반 상품으로 분류)
   - **예외단어 없음 + 모든 시즌 제외**: 제외

**시즌 타입별 처리**:
- **Event 타입**:
  - ACTIVE 기간 + 예외단어 있으면 제외
  - SOURCING/EXPIRED 기간이면 제외
- **Climate/Activity/Lifecycle 타입**:
  - 예외단어 무관하게 처리
  - SOURCING/EXPIRED 기간이어도 시즌 키워드가 있으면 시즌으로 분류

**상세 내용**: `데이터출고_시즌필터링_동작방식_상세.md` 참고

---

### 7단계: 조합 조회 (각 상품코드별) - **순환식 로직 적용**

**위치**: `database/db_handler.py:743-807`, `database/db_handler.py:855-1000`

**처리 방식**: **순환식 조합 선택** (2024-01-19 변경)

**처리 순서**:

1. **순환 로직 메서드 호출** (`get_next_combination_for_store`)
   - 스토어별 마지막 사용 인덱스 조회 (`store_combination_state` 테이블)
   - 해당 인덱스 이후의 조합 조회 (순환을 위해 이전 조합도 포함)

2. **URL 타입별 필터링 및 정렬**
   - URL이 있는 조합 (누끼/믹스)과 `name_only` 모두 포함
   - URL 타입별 번갈아가기: 마지막 사용 URL 타입의 반대 타입 우선
   - 예: 마지막이 'mix' → 'nukki' → 'mix' → 'name_only' 순서

3. **전체 시트 동일 조합 추적**
   - `global_used_combinations` 체크 (중복 방지)

4. **스토어별 조합 체크**
   - `exclude_assigned=False`일 때 `store_used_combinations` 체크

5. **상태 업데이트**
   - 선택된 조합의 인덱스와 URL 타입을 `store_combination_state`에 저장

**URL이 없는 경우 처리**:
- `name_only` 타입은 URL 없이 상품명만 제공 (기존 방식과 동일)
- URL 타입이 'mix'인데 mix_url이 없거나, 'nukki'인데 nukki_url이 없으면 제외
- **조합별로 함께 제공**되므로 URL과 상품명이 별도가 아닌 함께 처리됨 (기존 방식 유지)

---

### 8단계: 상품코드별 그룹화

**위치**: `ui/main_window.py:5878-5886`

**동작**:
- 카테고리별로 조회된 조합을 상품코드별로 그룹화
- `all_products_by_code = {product_code: [조합1, 조합2, ...]}`

**효과**: 같은 상품코드의 여러 조합 중에서 선택 가능

---

### 9단계: 우선순위 정렬

**위치**: `ui/main_window.py:5965-5991`

**적용 조건**: `exclude_assigned=True`이고 `total_quantity_limit`이 있을 때

**동작**:
1. 출고 이력 확인 (`global_used_combinations_db` 기준)
2. 출고된 적 없는 상품코드와 있는 상품코드 분리
3. 출고된 적 없는 상품코드를 먼저, 그 다음 출고된 적 있는 상품코드

**목적**: 수량 제한이 있을 때 새로운 상품코드를 우선적으로 출고

---

### 10단계: 상품코드별 처리 (루프)

**위치**: `ui/main_window.py:5993-6052`

**처리 순서**:

1. **등록된 상품수량 제한 체크**
   ```python
   if store_registered_limit is not None:
       if len(store_processed_codes) >= store_registered_limit:
           continue  # 스킵
   ```
   - 등록된 상품수량 초과 시 스킵

2. **스토어별 수량 제한 체크**
   ```python
   if total_quantity_limit is not None:
       if len(store_processed_codes) >= total_quantity_limit:
           continue  # 스킵
   ```
   - 수량 제한 초과 시 스킵

3. **exclude_assigned 재체크**
   ```python
   if exclude_assigned and product_code in store_used_product_codes:
       continue  # 스킵
   ```
   - 스토어별 이미 사용한 상품코드 제외

4. **전체 시트 동일 조합 추적**
   ```python
   combination_key = (product_code, url_type, line_index, final_name, used_url)
   if combination_key in global_used_combinations:
       continue  # 스킵
   ```
   - 전체 시트에서 이미 사용된 조합은 다른 스토어에서도 사용 불가

5. **exclude_assigned=False일 때 스토어별 조합 체크**
   ```python
   if not exclude_assigned and candidate_combination_key in store_used_combinations:
       continue  # 스킵
   ```
   - 같은 스토어에서 이미 사용한 조합은 제외

6. **사용 가능한 조합 찾기**
   - 상품코드별 조합 중에서 사용 가능한 조합 선택
   - `combination_index` 오름차순으로 순회

---

### 11단계: 최종 조합 할당 및 DB 기록

**위치**: `ui/main_window.py:6058-6161`

#### 11.1 조합 사용 표시

```python
if exclude_assigned:
    store_used_product_codes.add(product_code)
global_used_combinations.add(found_combination_key)
if not exclude_assigned:
    store_used_combinations.add(candidate_combination_key)
```

#### 11.2 DB 기록 (배치 INSERT)

**combination_assignments 테이블**:
```python
combination_assignments_batch.append(
    (sheet_name, business_number, product_code, combination_index)
)
```
- 모든 경우에 기록
- 배치 INSERT로 성능 최적화

**upload_logs 테이블**:
```python
if exclude_assigned and not skip_logging:
    upload_logs_batch.append((...))
```
- `exclude_assigned=True`일 때만 기록
- 배치 INSERT로 성능 최적화

#### 11.3 Excel 파일 저장

**위치**: `ui/main_window.py:6038-6161`

- 각 스토어별로 Excel 파일 생성
- 파일명: `{market_name}_{timestamp}.xlsx`
- 컬럼: 상품코드, 시트명, 스토어명, 카테고리, 사용URL, URL타입, 누끼url, 믹스url, ST4_최종결과, 줄번호, ST2_JSON, search_keywords

---

## 성능 최적화 현황

### 구현된 최적화

1. **시즌 설정 파일 캐싱**
   - 위치: `database/db_handler.py:641-650`
   - 효과: 카테고리마다 반복 로드 → 한 번만 로드

2. **combination_assignments 캐싱**
   - 위치: `ui/main_window.py:5344-5358`
   - 효과: 카테고리마다 반복 조회 → 시트별로 한 번만 조회

3. **store_used_product_codes 캐싱**
   - 위치: `ui/main_window.py:5360-5370`
   - 효과: 카테고리마다 반복 조회 → 스토어별로 한 번만 조회

4. **market_id 캐싱**
   - 위치: `ui/main_window.py:5627-5634`
   - 효과: 상품마다 반복 조회 → 시트별로 한 번만 조회

5. **배치 INSERT**
   - 위치: `ui/main_window.py:6065-6161`
   - 효과: 개별 INSERT → 배치 INSERT (COMMIT 횟수 감소)

6. **조합 조회 LIMIT**
   - 위치: `database/db_handler.py:756`
   - 효과: `LIMIT 100`으로 불필요한 조회 방지

7. **상품코드 필터링 조기 적용**
   - 위치: `database/db_handler.py:602-629`
   - 효과: 시즌 필터링 전에 적용하여 불필요한 시즌 필터링 방지

---

## 필터링 옵션별 동작 요약

### exclude_assigned 옵션

| 옵션 | 스토어별 상품코드 제외 | 스토어별 조합 제외 | DB 기록 | 동일 상품코드 재출력 |
|------|---------------------|------------------|---------|-------------------|
| True | ✅ 제외 | ❌ | upload_logs 기록 | ❌ 불가 |
| False | ❌ 포함 | ✅ 제외 | upload_logs 미기록 | ✅ 가능 (다른 조합) |

### 시즌 필터링

| 상태 | 일반 상품 | ACTIVE 시즌 | SOURCING 시즌 | EXPIRED 시즌 |
|------|---------|------------|--------------|--------------|
| Event 타입 | ✅ 포함 | 예외단어 없으면 포함 | ❌ 제외 | ❌ 제외 |
| Climate/Activity/Lifecycle | ✅ 포함 | ✅ 포함 | ✅ 포함 (시즌으로 분류) | ✅ 포함 (시즌으로 분류) |

### 상품코드 필터링

| 모드 | 동작 |
|------|------|
| none | 필터링 안 함 |
| exclude | 입력한 상품코드 제외 |
| include | 입력한 상품코드만 포함 |

---

## 코드 참조 위치

### 주요 파일

- **UI 로직**: `ui/main_window.py`
  - 데이터 출고 버튼: `5048-5096`
  - 필터링 옵션 확인: `5206-5243`
  - 필터링 실행: `5519-6161`

- **DB 로직**: `database/db_handler.py`
  - 상품 조회: `507-807`
  - 시즌 필터링: `631-724`
  - 상품코드 필터링: `602-629`

- **시즌 필터링**: `season_filter_manager_gui.py`
  - 시즌 필터링 함수: `filter_products_by_season()`
  - 시즌 감지: `_detect_seasons_from_product()`
  - 시즌 유효성 확인: `_check_season_validity()`

---

## 로그 출력 예시

### 시즌 필터링 결과

```
📊 카테고리 '홈/리빙>인테리어소품>장식품' 시즌 필터링 결과:
  - 전체 상품 코드: 4개
  - 일반 상품: 1개
  - 시즌 상품 (포함): 1개
  - 시즌 지난 상품 (제외): 2개
  - 필터링 후 상품 코드: 2개 → 조합 5개 생성

  ✅ 포함된 시즌 (출력 가능):
    - 한파: 1개

  ❌ 제외된 시즌:
    - 크리스마스 - 시즌 종료됨 - 1개
    - 발렌타인데이 - 소싱 기간 - 이미 가공 완료 - 1개
```

### 상품코드 필터링 결과

```
🔍 상품코드 필터링 (제외): 10개 상품코드 제외됨 (상품코드: 100개 → 90개, 조합: 500개 → 450개)
```

---

## 주의사항

1. **필터링 순서**: 상품코드 필터링 → 시즌 필터링 → 조합 조회 순서로 적용됨

2. **exclude_assigned 중복 체크**: `db_handler.py`에서 한 번, `main_window.py` 루프에서 한 번 체크됨 (현재 구현 상태)

3. **전체 시트 동일 조합 추적**: 시트별이 아닌 전체 시트에 대해 동일 조합 추적

4. **수량 제한**: 등록된 상품수량 제한이 스토어별 수량 제한보다 먼저 적용됨

5. **캐싱**: 시즌 설정 파일, combination_assignments, market_id는 캐싱되어 재사용됨

---

## 결론

데이터 출고 과정에서 다양한 필터링이 순차적으로 적용되어, 마켓에 업로드할 상품 조합을 선택합니다. 

**핵심 포인트**:
- ✅ 시트별/스토어별 캐싱으로 성능 최적화
- ✅ 배치 INSERT로 DB 쓰기 성능 향상
- ✅ 시즌 필터링으로 현재 시즌에 맞는 상품만 자동 선택
- ✅ 상품코드 필터링으로 특정 상품코드만 선택/제외 가능
- ✅ 전체 시트 동일 조합 추적으로 중복 방지

이러한 필터링 구조를 통해 올바른 상품만 데이터 출고 파일에 포함됩니다.
